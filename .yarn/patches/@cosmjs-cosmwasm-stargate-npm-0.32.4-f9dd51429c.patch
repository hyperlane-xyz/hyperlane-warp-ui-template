diff --git a/build/cosmwasmclient.js b/build/cosmwasmclient.js
index af8341db5333963a258b3476eb60690afca3473f..1fdb3081b454e5a69db7137f870f0f446f2cccf2 100644
--- a/build/cosmwasmclient.js
+++ b/build/cosmwasmclient.js
@@ -10,6 +10,112 @@ const utils_1 = require("@cosmjs/utils");
 const abci_1 = require("cosmjs-types/cosmos/base/abci/v1beta1/abci");
 const types_1 = require("cosmjs-types/cosmwasm/wasm/v1/types");
 const modules_1 = require("./modules");
+
+/* Code copied in from injective SDK to avoid importing all 9Mb of the library */
+// node_modules/@injectivelabs/core-proto-ts/cjs/google/protobuf/any.js
+const minimal_1 = require("protobufjs/minimal");
+const Any = {
+    decode(input, length) {
+        const reader = input instanceof minimal_1.Reader ? input : minimal_1.Reader.create(input);
+        let end = length === undefined ? reader.len : reader.pos + length;
+        const message = { typeUrl: "", value: new Uint8Array(0) };
+        while (reader.pos < end) {
+            const tag = reader.uint32();
+            switch (tag >>> 3) {
+                case 1:
+                    if (tag !== 10) {
+                        break;
+                    }
+                    message.typeUrl = reader.string();
+                    continue;
+                case 2:
+                    if (tag !== 18) {
+                        break;
+                    }
+                    message.value = reader.bytes();
+                    continue;
+            }
+            if ((tag & 7) === 4 || tag === 0) {
+                break;
+            }
+            reader.skipType(tag & 7);
+        }
+        return message;
+    },
+  };
+  // node_modules/@injectivelabs/core-proto-ts/cjs/cosmos/auth/v1beta1/auth.js
+const BaseAccount = {
+    decode(input, length) {
+        const reader = input instanceof minimal_1.Reader ? input : minimal_1.Reader.create(input);
+        let end = length === undefined ? reader.len : reader.pos + length;
+        const message = { address: "", pubKey: undefined, accountNumber: "0", sequence: "0" };
+        while (reader.pos < end) {
+            const tag = reader.uint32();
+            switch (tag >>> 3) {
+                case 1:
+                    if (tag !== 10) {
+                        break;
+                    }
+                    message.address = reader.string();
+                    continue;
+                case 2:
+                    if (tag !== 18) {
+                        break;
+                    }
+                    message.pubKey = Any.decode(reader, reader.uint32());
+                    continue;
+                case 3:
+                    if (tag !== 24) {
+                        break;
+                    }
+                    message.accountNumber = reader.uint64().toString();
+                    continue;
+                case 4:
+                    if (tag !== 32) {
+                        break;
+                    }
+                    message.sequence = reader.uint64().toString();
+                    continue;
+            }
+            if ((tag & 7) === 4 || tag === 0) {
+                break;
+            }
+            reader.skipType(tag & 7);
+        }
+        return message;
+    },
+};
+// node_modules/@injectivelabs/core-proto-ts/cjs/injective/types/v1beta1/account.js
+const EthAccount = {
+    decode(input, length) {
+        const reader = input instanceof minimal_1.Reader ? input : minimal_1.Reader.create(input);
+        let end = length === undefined ? reader.len : reader.pos + length;
+        const message = { baseAccount: undefined, codeHash: new Uint8Array(0) };
+        while (reader.pos < end) {
+            const tag = reader.uint32();
+            switch (tag >>> 3) {
+                case 1:
+                    if (tag !== 10) {
+                        break;
+                    }
+                    message.baseAccount = BaseAccount.decode(reader, reader.uint32());
+                    continue;
+                case 2:
+                    if (tag !== 18) {
+                        break;
+                    }
+                    message.codeHash = reader.bytes();
+                    continue;
+            }
+            if ((tag & 7) === 4 || tag === 0) {
+                break;
+            }
+            reader.skipType(tag & 7);
+        }
+        return message;
+    },
+};
+
 class CosmWasmClient {
     /**
      * Creates an instance by connecting to the given CometBFT RPC endpoint.
@@ -67,9 +173,28 @@ class CosmWasmClient {
         const status = await this.forceGetCometClient().status();
         return status.syncInfo.latestBlockHeight;
     }
+    decodeInjectiveAccount(injAccount){ 
+        const account = EthAccount.decode(injAccount.value);
+        const baseAccount = account.baseAccount;
+        const pubKey = baseAccount.pubKey;
+        return {
+            address: baseAccount.address,
+            pubkey: pubKey
+                ? {
+                    type: '/injective.crypto.v1beta1.ethsecp256k1.PubKey',
+                    value: Buffer.from(pubKey.value).toString('base64'),
+                }
+                : null,
+            accountNumber: parseInt(baseAccount.accountNumber, 10),
+            sequence: parseInt(baseAccount.sequence, 10),
+        };
+    }
     async getAccount(searchAddress) {
         try {
             const account = await this.forceGetQueryClient().auth.account(searchAddress);
+            if (searchAddress.startsWith('inj')) {
+                return this.decodeInjectiveAccount(account);
+            }            
             return account ? (0, stargate_1.accountFromAny)(account) : null;
         }
         catch (error) {
diff --git a/build/signingcosmwasmclient.js b/build/signingcosmwasmclient.js
index 6eb95bb672698df8feba51dc5a06d33bbed616c5..5a9d32f6af5ad44435ac15534501efdc344609d8 100644
--- a/build/signingcosmwasmclient.js
+++ b/build/signingcosmwasmclient.js
@@ -93,6 +93,9 @@ class SigningCosmWasmClient extends cosmwasmclient_1.CosmWasmClient {
             throw new Error("Failed to retrieve account from signer");
         }
         const pubkey = (0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);
+        if (signerAddress.startsWith('inj')) {
+            pubkey['typeUrl'] = '/injective.crypto.v1beta1.ethsecp256k1.PubKey';
+        }
         const { sequence } = await this.getSequence(signerAddress);
         const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);
         (0, utils_1.assertDefined)(gasInfo);
@@ -116,7 +119,8 @@ class SigningCosmWasmClient extends cosmwasmclient_1.CosmWasmClient {
         if ((0, stargate_1.isDeliverTxFailure)(result)) {
             throw new Error(createDeliverTxResponseErrorMessage(result));
         }
-        const codeIdAttr = findAttribute(result.events, "store_code", "code_id");
+        const rawCodeIdAttr = findAttribute(result.events, "cosmwasm.wasm.v1.EventCodeStored", "store_code", "code_id");
+        const codeIdAttr = { value: rawCodeIdAttr.value.replace(/\"/g, "") };
         return {
             checksum: (0, encoding_1.toHex)((0, crypto_1.sha256)(wasmCode)),
             originalSize: wasmCode.length,
@@ -397,6 +401,9 @@ class SigningCosmWasmClient extends cosmwasmclient_1.CosmWasmClient {
             throw new Error("Failed to retrieve account from signer");
         }
         const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
+        if (signerAddress.startsWith('inj')) {
+            pubkey['typeUrl'] = '/injective.crypto.v1beta1.ethsecp256k1.PubKey';
+        }        
         const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
         const msgs = messages.map((msg) => this.aminoTypes.toAmino(msg));
         const signDoc = (0, amino_1.makeSignDoc)(msgs, fee, chainId, memo, accountNumber, sequence, timeoutHeight);
